Mitch Gavars
Professor Meng
Lab11 - answers.txt
4/02/19

(1.1)
Run over1 and enter an input string with more than 10 characters and note what happens. Run over2, enter the same input string you used before, and note any difference in behavior in comparison with the first program. Explain how the buffer overflow risk was eliminated in over2.c.

over1 printed out all of the string over 10 characters, but over2 cut it off after 9 characters. Because gets() reads a line into the buffer until a terminating newline or EOF, while fgets() reads in up to one less than the size of the stream.

(1.2)
Now, run over3 and enter your same input string. Read the source code in over3.c and explain what causes the risk of buffer overflow in this program.

The risk of buffer overflow in this is caused by using scanf(), because that just reads directly what is typed in. 

(1.3)
Consider the flaws you identified in over1.c and over3.c, then generalize from your observations to write a rule of thumb that allows anyone to identify when a system call or library function call will give a program the risk of buffer overflows.

The risk of overflow occurs when you do not leave space for a null character at 
the end of a char[]. 

(1.4)
Comparing over3.c and over4.c, you learn a lesson on how to handle user input to avoid the risk of buffer overflows. Try to state this lesson as clearly as possible.

It is hard to manage the risk of buffer overflow with user inputs when you have a limited length of characters in an array. Using scanf("%9s", acctNumberStr) works in this case but only because acctNumberStr is of length 10. It works but must be careful while hardcoding it.

(1.5)
Construct a proof-of-concept program called over5.c to show how a certain function can introduce the risk of buffer overflow. The function you choose must be different from those that appeared earlier in this problem. The list that follows offers a few candidates for you to consider: strcat, strcpy, sprintf. You can try it on different machines with different compilers, e.g., cc on mips, or cc on the lab Linux machines. You might get different results. Try to explain what you see.

(2.1) Reading the source code and decode-run.txt, determine in which segment of memory does each of these five address appear.

&main = 0x561b7a3c
&i = 0x7fa61b18
&j = 0x7fa61b1c
&k = 0x7fa61afc
&buf[0] = 0x7fa61af0

main is in the data segment of memory
i, j, k, and buf are in the stack segement of memory

(2.2)  In a text editor, open the file decode.s provided to you, which contains the compilation from C to assembly. Look at the code in main to identify the point at which it sets up the parameters to pass in the invocation to function test. The function prototype of this C function has 6 formal arguments as shown below:

void test(int a, int b, int c, int d, int i, int j)

Knowing that MIPS can pass up only to 4 arguments using registers $a0-$a3, you realize that the two additional arguments i and j have to be passed to the function via the stack. The question is in which order these parameters are pushed onto the stack: from left to right or from right to left? Referring to the assembly code in main, specify how each of the 6 parameters is passed on to function test and  note the order in which the parameters that are passed on the stack are pushed onto the stack.

a,b,c,d are not passed onto the stack because they are passed to the first four available registers. Each of these values is then put through the function. i and j are pushed onto the stack because there are no available registers for them.They are pushed onto the stack with j being pushed before i because i needs to run through the function first. When it is time for i and j to be run through the function, i will be popped off first and assigned a register to be run through the function and then j will go through the same thing.

(2.3) Write down in your answers.txt the addresses of i, j, buf[0], stack frame pointer, the address where the return address is stored, and the value of the return address.

&main = 0x561b7a3c
&i = 0x7fa61b18
&j = 0x7fa61b1c
&k = 0x7fa61afc
&buf[0] = 0x7fa61af0

ra = 0x55555a8c
value of ra = 0x7fffe528

(2.4) Look at the address of the variable i that is generated by running decode.  Knowing that it is a 32-bit integer, give the hexadecimal value of each of the 4 individual bytes make up this value (you know that it represents 11, the actual parameter passed from main to test) along with their byte addresses.

0x7feb5938: 0x0b
0x7feb5939: 0x00
0x7feb593a: 0x00
0x7feb593b: 0x00

(2.5) Looking at how the individual bytes that constitute the value of i are stored in memory, determine whether you are in a little endian or in a big endian processor.

We are in a big endian processor

(2.6) Thinking of how you determined the endian convention of your processor above, describe a strategy you might use in the future to discover what is the endian convention of an arbitrary processor. Your description can be a mixture of C statements and plain English to explain it step-by-step.

If you know the value of your variable, you can determine if the value is being stored in the beginning of the endian or at the end. If it is stored at the beginning, then it is big endian being used, and if the variable is being stored at the end, then it is little endian. 

(2.7) Using the information you gathered so far, draw the stack frame for function test. Your must show the address each component of the stack frame for test, including each of the local variables in the function individually

 a, b, c, d, i, and j will be on the stack. The local variables, k and the buffer, will also be on the stack. 
      main is contained in the data segment of memory.
      a, b, c, d, i, j, k, and buf are contained in the stack segment of memory.
      main:
      &main = 0x55fa7a3c
      a:
      0x7feb5928: 0x01
      0x7feb5929: 0x00
      0x7feb592a: 0x00
      0x7feb592b: 0x00
      b:
      0x7feb592c: 0x02
      0x7feb592d: 0x00
      0x7feb592e: 0x00
      0x7feb592f: 0x00
      c:
      0x7feb5930: 0x03
      0x7feb5931: 0x00
      0x7feb5932: 0x00
      0x7feb5933: 0x00
      d:
      0x7feb5934: 0x04
      0x7feb5935: 0x00
      0x7feb5936: 0x00
      0x7feb5937: 0x00
      i:
      0x7feb5938: 0x0b
      0x7feb5939: 0x00
      0x7feb593a: 0x00
      0x7feb593b: 0x00
      j:
      0x7feb593c: 0x0c
      0x7feb593d: 0x00
      0x7feb593e: 0x00
      0x7feb593f: 0x00
      k:
      0x7feb591c: 0x0c
      0x7feb591d: 0x00
      0x7feb591e: 0x00
      0x7feb591f: 0x00
      buf[]:
      &buf[0] = 0x7feb5910
      &buf[1] = 0x7feb5911
      &buf[2] = 0x7feb5912
      &buf[3] = 0x7feb5913
      &buf[4] = 0x7feb5914
      &buf[5] = 0x7feb5915
      &buf[6] = 0x7feb5916
      &buf[7] = 0x7feb5917
      &buf[8] = 0x7feb5918
      &buf[9] = 0x7feb5919
      &buf[10] = 0x7feb591a
      &buf[11] = 0x7feb591b

(2.8) Look at the stack frame diagram you constructed above. Stack smashing uses the lack of array bounds checking in C to force a program to make a jump to an arbitrary address – that is, the address of a piece of code injected into a running program. What data item in the stack frame must be overwritten to make this jump possible?
      It is possible. You can extend the data segment into the text segment. Your code would run into the data segment thinking it is still in the text segment. This would cause a jump in the code. 

(2.9) For the scenario in this problem up to now: if one injects code into your running program via buffer overflow, into which segment of the program will this end up: text, data, stack, or heap segment?
      A buffer overflow will be stored in the heap. This is because the stack has an overflow, so the information will fall into the heap section of the memory.

(2.10) You have learned about programs being structured into these four regions or “compartments,” the open question is how the processor deals with their boundaries. Would the processor possibly execute code that is not in the text segment? Would the processor be able to manipulate data stored in the text segment?
       No and no.

(2.11) If you precede the declaration of buf with the keyword static, this array will be visible in the scope of function test but it will reside on the data segment of your program rather than on the stack. Make this modification in the program, save the revised program in decode_static.c, compile, and run the program. Save the output into a file named decode-static-run.txt. Describe what evidence you find to confirm that buf is now in the data segment. Please do not overwrite your previously saved decode-run.txt file!
       The memory address of all of the buffers decreased to a lower value. The data segment of our program has significantly lower address values because they are lower in memory than do the addresses of the stack part of the memory.
       non static value: &buf[0] = 0x7feb5910
       static value: &buf[0] = 0x5557ce50

(2.12) Consider what you observed when you place buf in the data segment of the program. Explain whether it is possible to use a buffer overflow in buf in this situation to force the program to jump to an arbitrary address.
       Yes, it is possible. The buffer addresses are still smaller than the variable addresses. They come before the varaiables. The stack section of memory could fall into the data segment, and then you would be able to jump to an arbitrary address.     


(3.1)
Analyze the output of this program. In you answers.txt, Explain in your own words what makes concat.c an insecure program.

concat.c is an insecure program because the use of strcpy makes it vulnerable to a buffer overflow because it could copy in more characters than the array buf could allow. 

(3.2)
Now, also in your answers.txt, try to generalize from the experiences you’ve had in this lab to explain what type of programming “mistake” makes a program vulnerable to stack smashing attacks.

The most common programming "mistakes" that can make the program vulnerable to stack smashing attacks is working with strings ( arrays of characters ) because it is very easy to accidentally write more data to it than expected. We can see this in (3.1) by using strcpy in a for loop that could end up being too long.

(3.3)
Adapt concat.c to eliminate, or at least, minimize the risks of stack smashing. Once you have tried your best, make sure to run it through rats again to verify that you managed to improve it.




